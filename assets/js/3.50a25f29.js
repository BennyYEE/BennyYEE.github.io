(window.webpackJsonp=window.webpackJsonp||[]).push([[3],{168:function(t,_,e){"use strict";e.r(_);var r=e(0),a=Object(r.a)({},function(){var t=this,_=t.$createElement,e=t._self._c||_;return e("div",{staticClass:"content"},[t._m(0),t._v(" "),e("p",[t._v("非受检异常(unchecked exception)：Error、RuntimeException")]),t._v(" "),e("p",[t._v("受检异常(checked exception)：编译时异常IOException/SqlException")]),t._v(" "),e("p",[t._v("1、异常是主逻辑的补充逻辑，修改一个补充逻辑，就会导致主逻辑的修改，影响代码的规范和原则。")]),t._v(" "),e("p",[t._v("2、实现类的变更，它最终会影响调用者，破坏了一些封装性。")]),t._v(" "),e("p",[t._v("3、降低代码可读性。")]),t._v(" "),t._m(1),t._v(" "),t._m(2),t._v(" "),e("p",[t._v("JDK动态代理是通过接口的方法名，在动态生成代理类里面去调用业务实现类的同名方法，去实现拦截。")]),t._v(" "),e("p",[t._v("CGlib动态代理是通过继承具体需要被代理的业务类，去动态生成业务类的子类，去重写业务方法，实现代理。")]),t._v(" "),t._m(3),t._v(" "),e("p",[t._v("软件设计六大原则：")]),t._v(" "),t._m(4),t._v(" "),t._m(5),t._v(" "),e("p",[t._v("​\t落地支付网关")]),t._v(" "),t._m(6),t._v(" "),e("p",[t._v("​\t利用接口定义好规则，适配器实现接口，按接口规则接入各SDK，适配多套SDK，")]),t._v(" "),t._m(7),t._v(" "),t._m(8),t._v(" "),e("p",[t._v("​\tlist有序且允许重复")]),t._v(" "),e("p",[t._v("​\tset无序且不允许重复\n​\t\tHashSet/TreeSet   是对HashMap/TreeMapd的一个包装")]),t._v(" "),e("p",[t._v("​\tArrayList可变长度的动态数组（Object[]  默认长度10，扩容一次，长度变成原来的1.5倍。删除一个元素时，会让右边的元素全部左移一位）")]),t._v(" "),t._m(9),t._v(" "),e("p",[t._v("​\t我们都知道，我们写的程序是一个Java文件，然后最终会编译成一个class文件，通过若干个class文件，组织成一个完整的Java程序。当程序在运行的时候，调用一个main方法，作为一个入口，来执行程序的相关功能。")]),t._v(" "),e("p",[t._v("程序启动时，并不是一次性加载所有的class文件到内存中，而是根据程序的需要，通过类加载机制，去动态加载。")]),t._v(" "),t._m(10),t._v(" "),t._m(11),t._v(" "),e("p",[t._v("锁：是一个同步机制，它是保证在多线程并行执行的时候，对共享资源访问的安全性。")]),t._v(" "),e("p",[t._v("乐观锁（CAS、数据库的version字段）：每次获取或者修改共享资源数据时，认为是安全的，不会有锁的冲突。不会主动对共享资源加锁。但是在更新时，会判断是不是有其他线程对之前的数据做过变更。")]),t._v(" "),e("p",[t._v("悲观锁（synchronized锁）：")]),t._v(" "),t._m(12),t._v(" "),e("p",[t._v("Blocking IO\t同步阻塞IO")]),t._v(" "),e("p",[t._v("JDK1.4之前，Java.io，java.net都有对应的IO")]),t._v(" "),e("p",[t._v("IO：文件流，网络流")]),t._v(" "),e("p",[t._v("同步：是否要亲自去监听操作，不断进行关注：是否已经完成对应操作")]),t._v(" "),e("p",[t._v("阻塞：IO操作如果没有完成，在单线程的环境下，其他客户端是不能够连接上进行IO操作的。")]),t._v(" "),e("p",[t._v("JDK1.4之后，推出一个新的IO")]),t._v(" "),e("p",[t._v("NIO \tNew IO\tNon-Blocking IO 同步非阻塞的IO")]),t._v(" "),e("p",[t._v("非阻塞：\t不关心IO操作是否完成，直接返回")]),t._v(" "),e("p",[t._v("阻塞：在当线程的环境之后，如果IO操作没有完成，那么当线程就会等待，没有办法进行其他操作")]),t._v(" "),e("p",[t._v("AIO")]),t._v(" "),e("p",[t._v("​\t异步的理解：用户触发了IO操作之后，就不关心，委托给操作系统进行完成，当操作系统完成这个IO操作之后，再告诉自己就OK。")]),t._v(" "),t._m(13),t._v(" "),e("p",[t._v("set注入："),e("property",{ref:"",attrs:{name:""}})],1),t._v(" "),e("p",[t._v("构造注入："),e("constructor-arg",{ref:"",attrs:{index:"0",type:"java.lang.Object"}})],1),t._v(" "),e("p",[t._v("静态工厂注入")]),t._v(" "),t._m(14),t._v(" "),e("p",[t._v("事务具备ACID（原子性、一致性、隔离性、持续性）")]),t._v(" "),e("p",[t._v("事务并发问题：1.脏读、不可重复读（ 修改）、幻读（新增或删除）")]),t._v(" "),t._m(15),t._v(" "),t._m(16)])},[function(){var t=this.$createElement,_=this._self._c||t;return _("h2",{attrs:{id:"_1、受检异常和非受检异常的区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1、受检异常和非受检异常的区别","aria-hidden":"true"}},[this._v("#")]),this._v(" 1、受检异常和非受检异常的区别")])},function(){var t=this.$createElement,_=this._self._c||t;return _("h2",{attrs:{id:"_3、从一道面试题了解integer的实现"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3、从一道面试题了解integer的实现","aria-hidden":"true"}},[this._v("#")]),this._v(" 3、从一道面试题了解Integer的实现")])},function(){var t=this.$createElement,_=this._self._c||t;return _("h2",{attrs:{id:"_4、-动态代理原理分析"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4、-动态代理原理分析","aria-hidden":"true"}},[this._v("#")]),this._v(" 4、 动态代理原理分析")])},function(){var t=this.$createElement,_=this._self._c||t;return _("h2",{attrs:{id:"_5、设计模式的优雅落地"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5、设计模式的优雅落地","aria-hidden":"true"}},[this._v("#")]),this._v(" 5、设计模式的优雅落地")])},function(){var t=this,_=t.$createElement,e=t._self._c||_;return e("ol",[e("li",[t._v("单一职责原则：\n"),e("ol",[e("li",[t._v("优点：类的复杂度降低、可读性好、可维护性强、变更引起的风险降低")]),t._v(" "),e("li",[t._v("缺点：增加类或接口的维护成本")])])]),t._v(" "),e("li",[t._v("里氏替换原则：子类可以扩展父类的功能，但不能改变父类原有的功能。")]),t._v(" "),e("li",[t._v("依赖倒置原则：通过抽象，使各个类或者模块实现彼此独立，互不影响，实现模块之间的松耦合。如：面向接口编程。")]),t._v(" "),e("li",[t._v("接口隔离原则：尽量保证接口的纯洁性、单一性。")]),t._v(" "),e("li",[t._v("开闭原则：对扩展开放，对修改关闭。")]),t._v(" "),e("li",[t._v("迪米特法则：尽量将被依赖的类的实现逻辑封装进类的内部 ，不对外暴露。")])])},function(){var t=this.$createElement,_=this._self._c||t;return _("h3",{attrs:{id:"策略模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#策略模式","aria-hidden":"true"}},[this._v("#")]),this._v(" 策略模式")])},function(){var t=this.$createElement,_=this._self._c||t;return _("h3",{attrs:{id:"适配器模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#适配器模式","aria-hidden":"true"}},[this._v("#")]),this._v(" 适配器模式")])},function(){var t=this.$createElement,_=this._self._c||t;return _("h3",{attrs:{id:"工厂模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#工厂模式","aria-hidden":"true"}},[this._v("#")]),this._v(" 工厂模式")])},function(){var t=this.$createElement,_=this._self._c||t;return _("h2",{attrs:{id:"_6、从底层设计分析list和set的区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_6、从底层设计分析list和set的区别","aria-hidden":"true"}},[this._v("#")]),this._v(" 6、从底层设计分析List和Set的区别")])},function(){var t=this.$createElement,_=this._self._c||t;return _("h2",{attrs:{id:"_7、从原理层面分析classloader加载机制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_7、从原理层面分析classloader加载机制","aria-hidden":"true"}},[this._v("#")]),this._v(" 7、从原理层面分析ClassLoader加载机制")])},function(){var t=this.$createElement,_=this._self._c||t;return _("h2",{attrs:{id:"_9、如何将一个java对象序列化到文件中"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_9、如何将一个java对象序列化到文件中","aria-hidden":"true"}},[this._v("#")]),this._v(" 9、如何将一个Java对象序列化到文件中")])},function(){var t=this.$createElement,_=this._self._c||t;return _("h2",{attrs:{id:"_10、乐观锁和悲观锁的原理及应用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_10、乐观锁和悲观锁的原理及应用","aria-hidden":"true"}},[this._v("#")]),this._v(" 10、乐观锁和悲观锁的原理及应用")])},function(){var t=this.$createElement,_=this._self._c||t;return _("h2",{attrs:{id:"_11、bio、nio和aio面试"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_11、bio、nio和aio面试","aria-hidden":"true"}},[this._v("#")]),this._v(" 11、BIO、NIO和AIO面试")])},function(){var t=this.$createElement,_=this._self._c||t;return _("h2",{attrs:{id:"_12、spring中对象注入的几种方式及区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_12、spring中对象注入的几种方式及区别","aria-hidden":"true"}},[this._v("#")]),this._v(" 12、Spring中对象注入的几种方式及区别")])},function(){var t=this.$createElement,_=this._self._c||t;return _("h2",{attrs:{id:"_13、mysql数据库的隔离级别及其区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_13、mysql数据库的隔离级别及其区别","aria-hidden":"true"}},[this._v("#")]),this._v(" 13、Mysql数据库的隔离级别及其区别")])},function(){var t=this.$createElement,_=this._self._c||t;return _("h2",{attrs:{id:"_14、mysql有哪些存储引擎，区别？"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_14、mysql有哪些存储引擎，区别？","aria-hidden":"true"}},[this._v("#")]),this._v(" 14、MySql有哪些存储引擎，区别？")])},function(){var t=this,_=t.$createElement,e=t._self._c||_;return e("table",[e("thead",[e("tr",[e("th"),t._v(" "),e("th",[t._v("Innodb")]),t._v(" "),e("th",[t._v("Myisam")])])]),t._v(" "),e("tbody",[e("tr",[e("td",[t._v("存储文件")]),t._v(" "),e("td",[t._v(".frm表定义文件"),e("br"),t._v(".lbd数据文件")]),t._v(" "),e("td",[t._v(".frm表定义文件"),e("br"),t._v(".myd数据文件"),e("br"),t._v(".myi索引文件")])]),t._v(" "),e("tr",[e("td",[t._v("锁")]),t._v(" "),e("td",[t._v("表锁、行锁")]),t._v(" "),e("td",[t._v("表锁")])]),t._v(" "),e("tr",[e("td",[t._v("事务")]),t._v(" "),e("td",[t._v("ACID")]),t._v(" "),e("td",[t._v("不支持")])]),t._v(" "),e("tr",[e("td",[t._v("CRUD")]),t._v(" "),e("td",[t._v("读、写")]),t._v(" "),e("td",[t._v("读多")])]),t._v(" "),e("tr",[e("td",[t._v("count")]),t._v(" "),e("td",[t._v("扫表")]),t._v(" "),e("td",[t._v("有专门存储的地方")])]),t._v(" "),e("tr",[e("td",[t._v("索引结构")]),t._v(" "),e("td",[t._v("B+Tree")]),t._v(" "),e("td",[t._v("B+Tree")])]),t._v(" "),e("tr",[e("td"),t._v(" "),e("td"),t._v(" "),e("td")])])])}],!1,null,null,null);_.default=a.exports}}]);