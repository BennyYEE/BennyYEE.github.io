(window.webpackJsonp=window.webpackJsonp||[]).push([[4],{177:function(t,v,_){"use strict";_.r(v);var a=_(0),e=Object(a.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("div",{staticClass:"content"},[_("h2",{attrs:{id:"jvm-java虚拟机"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#jvm-java虚拟机","aria-hidden":"true"}},[t._v("#")]),t._v(" JVM java虚拟机")]),t._v(" "),_("h2",{attrs:{id:"_1、什么是jvm？"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1、什么是jvm？","aria-hidden":"true"}},[t._v("#")]),t._v(" 1、什么是JVM？")]),t._v(" "),_("p",[t._v("功能：")]),t._v(" "),_("p",[t._v("1、软件层面机器码翻译：帮程序员从软层面把我们认识的代码指令翻译成机器指令")]),t._v(" "),_("p",[t._v("2、内存管理")]),t._v(" "),_("h2",{attrs:{id:"_2、jvm运行时数据区"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2、jvm运行时数据区","aria-hidden":"true"}},[t._v("#")]),t._v(" 2、JVM运行时数据区")]),t._v(" "),_("h3",{attrs:{id:"native-interface-本地接口"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#native-interface-本地接口","aria-hidden":"true"}},[t._v("#")]),t._v(" Native Interface 本地接口")]),t._v(" "),_("p",[t._v("​\t本地接口的作用是融合不同的编程语言为Java所用。")]),t._v(" "),_("h3",{attrs:{id:"native-method-stack-本地方法栈"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#native-method-stack-本地方法栈","aria-hidden":"true"}},[t._v("#")]),t._v(" Native Method Stack 本地方法栈")]),t._v(" "),_("p",[t._v("​\t它的具体做法是Native Method Stack 中登记native方法，在Execution Engine 执行时加载本地方法库。")]),t._v(" "),_("h3",{attrs:{id:"pc寄存器"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#pc寄存器","aria-hidden":"true"}},[t._v("#")]),t._v(" PC寄存器")]),t._v(" "),_("p",[t._v("​\t每个线程都有一个程序计数器，是线程私有的，就是一个指针，指向方法区中的方法字节码（用来存储指向下一条指令的地址，即：将要执行的指令代码），由执行引擎读取下一条指令，是一个非常小的内存空间，几乎可以忽略不计。")]),t._v(" "),_("h3",{attrs:{id:"程序计数器"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#程序计数器","aria-hidden":"true"}},[t._v("#")]),t._v(" 程序计数器")]),t._v(" "),_("p",[t._v("​\t指向当前线程正在执行的字节码指令的地址 行号")]),t._v(" "),_("h3",{attrs:{id:"虚拟机栈"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#虚拟机栈","aria-hidden":"true"}},[t._v("#")]),t._v(" 虚拟机栈")]),t._v(" "),_("p",[t._v("​\t存储当前线程运行方法是所需要的数据、指令和返回地址")]),t._v(" "),_("p",[t._v("​\t栈桢：一个方法对应一个栈桢")]),t._v(" "),_("h3",{attrs:{id:"method-area-方法区"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#method-area-方法区","aria-hidden":"true"}},[t._v("#")]),t._v(" Method Area 方法区")]),t._v(" "),_("p",[t._v("​\t方法区是被所有线程共享，所有字段和方法字节码，以及一些特殊方法如构造函数，接口代码也在此定义。")]),t._v(" "),_("p",[t._v("​\t简单说，所有定义方法的信息都保存在该区域，此区属于共享区间。")]),t._v(" "),_("p",[t._v("​\t静态变量、常量、类信息（构造方法/接口定义）、运行时常量池 存在方法区中。")]),t._v(" "),_("h2",{attrs:{id:"_3、内存模型jmm"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3、内存模型jmm","aria-hidden":"true"}},[t._v("#")]),t._v(" 3、内存模型JMM")]),t._v(" "),_("p",[t._v("​\t对象的生命周期不一样，所以需要分代")]),t._v(" "),_("p",[t._v("​\t新生代")]),t._v(" "),_("p",[t._v("​\t\t98%的对象在minor gc的时候会被回收掉，基于复制回收算法，为了提高内存利用率，所以设置了8:1:1的 eden区、s0区 和 s1区，这样就有90%的内存空间能被使用")]),t._v(" "),_("p",[t._v("​\t老年代")]),t._v(" "),_("p",[t._v("​\t原空间（Meta Space JDK1.8）永久代（<JDK1.8）")]),t._v(" "),_("p",[t._v("​\t什么样的对象需要被GC")]),t._v(" "),_("p",[t._v("​\t\t判断算法\n​\t\t\t— 引用计数器")]),t._v(" "),_("p",[t._v("​\t\t\t— 可达性分析")]),t._v(" "),_("p",[t._v("​\t\t\t\t哪些对象能成为GC Root")]),t._v(" "),_("p",[t._v("​\t\t\t\t\t虚拟机栈中：本地变量表引用的对象")]),t._v(" "),_("p",[t._v("​\t\t\t\t\t方法区中：类静态变量引用的对象、常量引用的对象")]),t._v(" "),_("p",[t._v("​\t\t\t\t\t本地方法栈中：JNI引用的对象")]),t._v(" "),_("p",[t._v("​")]),t._v(" "),_("p",[t._v("​\t\t\t— 不可达是不是一定会被回收？不")]),t._v(" "),_("p",[t._v("​\t\t\t\tfinalize() 看此方法中还会不会对该对象进行挽救，让其可达。但尽量不要去挽救")]),t._v(" "),_("p",[t._v("​\t对象分配eden")]),t._v(" "),_("p",[t._v("​\t-XX:SurvivorRatio=8\t8:1:1")]),t._v(" "),_("p",[t._v("​")]),t._v(" "),_("p",[t._v("​\tTLAB  Thread Local Allaction Buffer")]),t._v(" "),_("p",[t._v("​\t对象很大")]),t._v(" "),_("p",[t._v("​\t\t-XX:PretenureSizeThreshold=3145728\t3M")]),t._v(" "),_("p",[t._v("​\t长期存活的对象")]),t._v(" "),_("p",[t._v("​\t\t-XX:MaxTenuringThreshold=15\t默认是15，一次Minor GC是一岁")]),t._v(" "),_("p",[t._v("​\t动态对象年龄判定")]),t._v(" "),_("p",[t._v("​\t\t相同年龄所有对象的大小总和  >  Survivor空间的一半")]),t._v(" "),_("p",[t._v("​\t分配担保")]),t._v(" "),_("p",[t._v("​\t\tMinor GC 之前检查")]),t._v(" "),_("p",[t._v("​\t\t老年代最大可用连续空间是否>新生代所有对象总空间")]),t._v(" "),_("p",[t._v("​\tMinor GC  + Major GC = Full GC")]),t._v(" "),_("p",[t._v("什么样的对象需要回收？")]),t._v(" "),_("p",[t._v("判断算法")]),t._v(" "),_("p",[t._v("引用")]),t._v(" "),_("p",[t._v("​\t强：Object object = new Object();")]),t._v(" "),_("p",[t._v("​\t软：判断内存空间不够时才回收")]),t._v(" "),_("p",[t._v("​\t弱：只要GC 就会回收")]),t._v(" "),_("p",[t._v("​\t虚：引用时会被通知")]),t._v(" "),_("h2",{attrs:{id:"_4、垃圾收集器"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4、垃圾收集器","aria-hidden":"true"}},[t._v("#")]),t._v(" 4、垃圾收集器")]),t._v(" "),_("p",[t._v("垃圾回收")]),t._v(" "),_("p",[t._v("​\t方法论：")]),t._v(" "),_("p",[t._v("​\t\t标记-清除算法")]),t._v(" "),_("p",[t._v("​\t\t复制回收算法")]),t._v(" "),_("p",[t._v("​\t\t标记-整理算法")]),t._v(" "),_("p",[t._v("​\t垃圾收集器")]),t._v(" "),_("p",[t._v("​\t\tSTW\tStop The World")]),t._v(" "),_("p",[t._v("​\t\tSerial")]),t._v(" "),_("p",[t._v("​\t\tParNew")]),t._v(" "),_("p",[t._v("​\t\t\t-XX:ParallelGCThreads")]),t._v(" "),_("p",[t._v("​\t\tParallel Scavenge(全局)")]),t._v(" "),_("p",[t._v("​\t\t\t吞吐量 = 运行用户代码时间 / （运行用户代码时间 + 垃圾收集时间）")]),t._v(" "),_("p",[t._v("​\t\t\t-XX:MaxGcPauseMillis=n")]),t._v(" "),_("p",[t._v("​\t\t\t-XX:GCTimeRetio=n")]),t._v(" "),_("p",[t._v("​\t\t\t-XX:UseAdaptiveSizePolicy\tGC\tErgonomics")]),t._v(" "),_("p",[t._v("​\t\tSerial Old")]),t._v(" "),_("p",[t._v("​\t\t\t标记-整理算法")]),t._v(" "),_("p",[t._v("​\t\t\tCMS备用预案\tConcurrent Mode Failure时使用")]),t._v(" "),_("p",[t._v("​\t\tParallel Old")]),t._v(" "),_("p",[t._v("​\t\t\t标记-整理算法")]),t._v(" "),_("p",[t._v("​\t\tCMS")]),t._v(" "),_("p",[t._v("​\t\t\t标记-清除算法")]),t._v(" "),_("p",[t._v("​\t\t\t减少回收停顿时间")])])}],!1,null,null,null);v.default=e.exports}}]);